# Chapter03. 연산자(Operator)

<br/>

# 1. 연산자

연산자는 **연산을 수행하는 기호**를 말한다.

## 연산자와 피연산자

> **연산자(operator)** : 연산을 수행하는 기호(+,-,*,/ 등)  
> **피연산자(operand)** : 연산자의 작업 대상 (변수, 상수, 리터럴, 수식)  

연산자는 피연산자로 연산을 수행하고 나면 항상 결과값을 반환한다.  

<br/>

## 식과 대입연산자

**연산자와 피연산자를 조합하여 계산하고자하는 바를 표현한 것**을 `식(expression)`이라고 한다. 그리고 **식을 계산하여 결과를 얻는 것**을 `식을 평가(evaluation)한다`고 한다.  
하나의 식을 평가(계산)하면, 단 하나의 결과를 얻는다. 이 결과를 대입연산자`=`를 사용해서 변수와 같이 값을 저장할 수 있는 공간에 저장해야 의미가 있다.  

<br/>

## 연산자의 종류

- **산술 연산자** : `+` `-` `*` `/` `%` `<<` `>>`  
- **비교 연산자** : `>` `<` `>=` `<=` `==` `!=`  
- **논리 연산자** : `&&` `||` `!` `&` `|` `^` `~`  
- **대입 연산자** : `=`
- **기타** : `(type) ?: instanceof`  

### 1. 피연산자의 개수에 따른 분류

피연산자의 개수가 하나면 **단항 연산자**, 두 개면 **이항 연산자**, 세 개면 **삼항 연산자**라고 부른다.  

<br/>

## 연산자의 우선순위과 결합규칙

식에 사용된 연산자가 둘 이상인 경우, 연산자의 우선순위에 의해 연산순서가 결정된다.  

### 1. 연산자의 결합규칙

하나의 식에 같은 우선순위의 연산자들이 여러 개 있는 경우 **연산자의 결합규칙**에 따라 순서가 정해진다.  

연산자의 결합규칙은 연산자마다 다르지만, 대부분 왼쪽에서 오른쪽의 순서로 연산을 수행하고, 단항 연산자와 대입 연산자만 그 반대로, 오른쪽에서 왼쪽의 순서로 연산을 수행한다.   

```
3 + 4 - 5 // 연산자의 결합규칙이 왼쪽에서 오른쪽인 경우 (->)
x = y = 3 // 연산자의 결합규칙이 오른쪽에서 왼쪽인 경우 (<-)
```

> 1. **산술 > 비교 > 논리 > 대입** 순서로 연산이 진행된다.  
> 2. **단항 > 이항 > 삼항**의 순서로 연산이 진행된다.  
> 3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.  

<br/>

## 산술 변환(usual arithmetic conversion)
이항 연산자는 두 피연산자의 타입이 일치해야 연산이 가능하므로, 피연산자의 타입이 서로 다르다면 연산 전에 형변환 연산자로 타입을 일치시켜야 한다.  
대부분의 경우, 두 피연산자의 타입 중에서 더 큰 타입으로 일치시키는데, 그 이유는 작은 타입으로 형변환하면 원래의 값이 손실될 가능성이 있기 때문이다. 

이처럼 **연산 전에 피연산자 타입의 일치를 위해 자동 형변환되는 것**을 `산술 변환` 또는 `일반 산술 변환`이라 하며, 이 변환은 이항 연산에서만 아니라 단항 연산에서도 일어난다.  

1. **두 피연산자의 타입을 같게 일치시킨다. (보다 큰 타입으로 일치)**  
long + int -> long + long -> long  
float + int -> float + float -> float  
double + float -> double + double -> double  

2. **피연산자의 타입이 int보다 작은 타입이면 int로 변환한다.**   
byte + short -> int + int -> int  
char + short -> int + int -> int  

**연산결과의 타입 또한 피연산자의 타입과 일치한다**는 것에 주목해야 한다.  
int와 int의 나눗셈 결과는 int이기 때문에 5 / 2 의 결과는 2.5가 아닌 2이다.  
실수를 얻고자 한다면 피연산자 중 어느 한 쪽을 float와 같은 실수형으로 형변환 해야한다. 그러면, 다른 한 쪽은 산술 변환의 첫 번째 규칙에 의해 자동적으로 형변환되어 두 피연산자 모두 실수형이 되고, 연산결과 역시 실수형의 값을 얻을 수 있다.
 
<br/><br/>

# 2. 단항 연산자

<br/>

## 증감 연산자 ++ --

증감연산자는 **피연산자에 저장된 값을 1 증가 또는 1 감소**시킨다. 증감연산자의 피연산자로 정수와 실수 모두 가능하지만, 상수는 값을 변경할 수 없으므로 불가능하다.  
증감연산자는 일반 산술 변환에 의해 자동 형변환이 발생하지 않으며, 연산결과의 타입은 피연산자의 타입과 같다.  

> **증가 연산자(++)** : 피연산자의 값을 1 증가시킨다.  
> **감소 연산자(--)** : 피연산자의 값을 1 감소시킨다.  

증감연산자는 연산자의 위치에 따라 **전위형(prefix)**, **후위형(postfix)**로 나뉜다.  

- **전위형**  
값이 참조되기 전에 증가시키다. (j = ++i;)  
- **후위형**  
값이 참조된 후에 증가시킨다. (j = i++;)  

그러나 증감연산자가 수식이나 메서드에 포함되지 않고 독립적인 하나의 문장으로 쓰인 경우에는 전위형과 후위형의 차이가 없다. [[예제 3-1]](./OperatorEx1.java)  
위와 달리 다른 수식에 포함되거나 메서드의 매개변수로 사용된 경우 전위형과 후위형의 결과는 다르다. [[예제 3-2]](./OperatorEx2.java), [[예제 3-3]](./OperatorEx3.java)  

증감연산자를 사용하면 코드가 간결해지지만, 지나치면 코드가 복잡해서 이해하기 어려워지기도 한다. 따라서 하나의 식에서 증감연산자의 사용을 최소화하고, 식에 두 번 이상 포함된 변수에 증감연산자를 사용하는 것은 지양해야 한다.  

<br/>

## 부호 연산자 + -

부호 연산자는 boolean형과 char형을 제외한 기본형에만 사용할 수 있다. [[예제 3-4]](./OperatorEx4.java)  

<br/><br/>

# 3. 산술 연산자

산술 연산자에는 사칙 연산자(`+`,`-`,`*`,`/`)와 나머지 연산자(`%`)가 있다.

<br/>

## 사칙 연산자 + - * /

사칙 연산은 곱셈(*), 나눗셈(/), 나머지(%) 연산자가 덧셈(+), 뺄셈(-)연산자보다 우선순위가 높으므로 먼저 처리된다. 그리고 피연산자가 정수형인 경우, 나누는 수로 0을 사용할 수 없다.

- 사칙 연산 예제 [[예제 3-5]](./OperatorEx5.java)  
- nt형보다 작은 byte형을 연산하게 되면 두 개의 피연산자들의 자료형이 자동적으로 int형으로 변환된 다음 연산이 수행되기 때문에 명시적으로 형변환을 해주어야 한다. [[예제 3-6]](./OperatorEx6.java)  
- 그러나 큰 자료형에서 작은 자료형으로 변환하면 데이터의 손실이 발생하므로 값이 바뀔 수 있다. [[예제 3-7]](./OperatorEx7.java)  
- int타입과 int타입의 연산결과는 int타입이기 때문에 long영으로 자동 형변환되어도 값은 변하지 않는다. [[예제 3-8]](./OperatorEx8.java)  
- int타입과 int타입의 연산결과는 int인데, 연산결과가 int타입의 최대값을 넘으면 오버플로우(overflow)가 발생한다. 이미 오버플로우가 발생한 값을 long형 타입의 변수에 저장해도 소용이 없다. [[예제 3-9]](./OperatorEx9.java)  
- 같은 의미의 식이라도 연산의 순서에 따라 다른 결과를 얻을 수 있다. 먼저 곱하는 경우 int의 범위를 넘어서기 때문에 오버플로우가 발생할 수 있다. [[예제 3-10]](./OperatorEx10.java)  
- 사칙연산의 피연산자로 숫자뿐만 아니라 문자도 가능하다. 문자는 실제로 해당 문자의 윤코드(부호없는 정수)로 바뀌어 저장되므로 문자간의 사칙연산은 정수간의 연산과 동일하다. [[예제 3-11]](./OperatorEx11.java), [[예제 3-12]](./OperatorEx12.java)   
- 상수 또는 리터럴 간의 연산은 실행 과정동안 변하는 값이 아니기 때문에, 컴파일 시에 멐파일러가 계산해서 그 결과로 대체함으로써 코드를 보다 효율적으로 만든다. 일부러 뻔한 리터럴 연산을 풀어쓸 필요는 없지만 코드의 가독성과 유지보수를 위해 그렇게 하는 경우가 있다. 풀어 써도 결국 컴파일러에 의해 미리 계산되기 때문에 실행 시의 성능차이는 없다. [[예제 3-13]](./OperatorEx13.java)   
- 소문자a\~z, 대문자 A\~Z, 숫자0\~9까지 연속적으로 코드가 지정되어 있다. [[예제 3-14]](./OperatorEx14.java)   
- 대문자와 소문자 간 코드값 차이는 10진수로 32이다. 이 사실을 이용하여 소문자를 대문자로 변환할 수 있다. [[예제 3-15]](./OperatorEx15.java)   
- 연산자의 성질을 이용하여 실수형의 값을 소수점 셋째 자리까지만 빼낼 수 있다.[[예제 3-16]](./OperatorEx16.java)   
- 연산자의 성질을 이용하여 실수형의 값을 반올림하여 소수점 셋째 자리까지만 빼낼 수 있다.[[예제 3-17]](./OperatorEx17.java)   
- Math.round() 메서드를 이용해 위보다 간단하게 반올림할 수 있다. [[예제 3-18]](./OperatorEx18.java)   

<br/>

## 나머지 연산자 %

니머지 연산자는 왼쪽의 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값을 결과로 반환하는 연산자이다.  
나눗셈에서는 나누는 수를 0으로 사용할 수 없다는 점에 주의해야 한다.  

- 나눗셈 연산자와 나머지 연산자를 이용해서 몫과 나머지를 구한다. [[예제 3-19]](./OperatorEx19.java)  
- 나누는 수로 음수도 허용하지만 부호는 무시되므로 결과는 음수의 절대값으로 나눈 나머지와 같다.  [[예제 3-20]](./OperatorEx20.java)  

<br/><br/>

# 4. 비교 연산자

<br/>

비교 연산자는 **두 피연산자를 비교하는 데 사용되는 연산자**로, 연산결과는 오직 true와 false둘 중 하나이다.  
비교 연산자 역시 이항 연산자이므로 비교하는 피연산자의 타입이 서로 다를 경우에는 자료형의 범위가 큰 쪽으로 자동 형변환되어 피연산자의 타입을 일치시킨 후에 비교한다는 점에 주의해햐 한다.  

## 대소비교 연산자 < > <= >=

두 피연산자의 값의 크기를 비교하는 연산자이다. 참이면 true, 거짓이면 false를 반환한다. 기본형 중에서는 boolean형을 제외한 나머지 자료형에 다 사용할 수 있지만 참조형에는 사용할 수 없다.

<br/>

## 등가비교 연산자 == !=

두 피연산자의 값이 같은지 또는 다른지를 비교하는 연산자이다. 대소비교 연산자와 달리, 기본형은 물론 참조형, 즉 모든 자료형에 사용할 수 있다. 기본형의 경우 변수에 저장되어 있는 값이 같은지를 알 수 있고, 참조형의 경우 객체의 주소값을 저장하기 때문에 두 개의 피연산자가 같은 객체를 가리키고 있는지를 알 수 있다.  
기본형과 참조형은 서로 형변환이 가능하지 않기 때문에 등가비교 연산자로 기본형과 참조형을 비교할 수 없다.  

- 비교 연산자도 이항 연산자이므로 연산을 수행하기 전에 형변환을 통해 두 피연산자의 타입을 같게 맞춘 다음 피연산자를 비교한다. [[예제 3-21]](./OperatorEx21.java)  
- 정수형은 실수형과 달리 근사값으로 저장되기 때문에 오차가 발생할 수 있다. double타입의 값과 float타입의 값을 비교할 때 오차 없이 올바른 결과를 얻기 위해서는 double타입의 값을 float타입으로 형변환한 다음 비교하면 된다. [[예제 3-22]](./OperatorEx22.java)  

### 1. 문자열의 비교

두 문자열을 비교할 때는 비교연산자 `==`대신 `equals()`메서드를 사용해야 한다.  
비교 연산자는 두 문자열이 완전히 같은 것인지 비교할 뿐이므로, 문자열의 내용이 같은지를 비교하기 위해서는 equals()를 사용하는 것이다.

```
String str = new String("abc");
boolean result = str.equals("abc");	// true
```

원래 String은 클래스이므로, `new`연산자를 사용해서 객체를 생성해야 한다.  
그러나 특별히 String만 new를 사용하지 않고, new연산자 없이 간단히 쓸 수 있게 허용한다.  

- equals()는 객체가 달라도 내용이 같으면 true를 반환하기 때문에 문자열을 비교할 때는 항상 equals()메서드를 사용해야 한다. [[예제 3-23]](./OperatorEx23.java)  

<br/><br/>

# 5. 논리 연산자

<br/>

논리 연산자는 **둘 이상의 조건을 `그리고(AND)`나 `또는(OR)`으로 연결하여 하나의 식으로 표현할 수 있게 해준다.**  

## 논리 연산자 - &&, ||, !

> **|| (OR결합)** : 피연산자 중 어느 한 쪽만 true이면 true를 결과로 얻는다.  
> **&& (AND결합)** : 피연산자 양족 모두 true이어야 true를 결과로 얻는다.  

- 예제 [[예제 3-24]](./OperatorEx24.java)  
- 사용자로부터 입력받은 값이 문자인지 숫자인지 확인하는 예제 [[예제 3-25]](./OperatorEx25.java)  

### 1. 효율적인 연산(short circuit evaluation)

논리 연산자는 효율적인 연산을 한다는 특징이 있다.  
OR연산`||`의 경우, 투 연산자 중 어느 한쪽만 '참'이어도 전체 연산결과가 '참'이므로 **좌측 피연산자가 true이면, 우측 피연산자의 값은 평가하지 않는다.**  
AND연산`&&`의 경우도 어느 한쪽만 '거짓'이어도 전체 연산결과가 '거짓'이므로 **좌측 피연산자가 false이면, 우측 피연산자는 평가하지 않는다.**  

그래서 같은 조건식이라도 피연산자의 위치에 따라서 연산속도가 달라질 수 있는 것이다.  
OR연산`||`의 경우엔 연산결과가 참일 확룔이 높은 피연산자를 연산자의 왼쪽에 놓아야 더 빠른 연산결과를 얻을 수 있다.  

- 우측 피연산자를 평가하지 않은 것을 확인할 수 있다. [[예제 3-26]](./OperatorEx26.java)  

### 2. 논리 부정 연산자 !

어떤 값에 논리 부정 연산자 `!`를 반복적으로 적용하면, 참과 거짓이 차례대로 반복된다.  
이 연산자의 이러한 성질을 이용하면 한번 누르면 켜지고, 다시 한 번 누르면 꺼지는 TV의 전원버튼과 같은 토글 버튼(toggle button)을 논리적으로 구현할 수 있다.  

논리 부정 연산자가 주로 사용되는 곳은 조건문과 반복문의 조건식이며, 이 연산자를 잘 사용하면 조건식이 보다 이해하기 쉬워진다. [[예제 3-7]](./OperatorEx27.java)  

<br/>

## 비트 연산자 & | ^ ! << >>

비트 연산자는 **피연산자를 비트단위로 논리 연산한다.** 피연산자를 이진수로 표현했을 때의 각 자리를 규칙에 따라 연산을 수해앟며, 피연산자로는 실수는 허용하지 않고 정수(문자포함)만 허용된다.  

> | (OR연산자) : 피연산자 중 한쪽의 값이 1이면, 1을 결과로 얻고, 그 외에는 0을 얻는다.  
> & (AND연산자) : 피연산자 양 쪽이 모두 1이어야만 1을 결과로 얻고, 그 외에는 0을 얻는다.  
> ^ (XOR연산자) : 피연산자의 값이 서로 다를 때만 1을 결과로 얻고, 같을 때는 0을 얻는다.  

비트OR연산자 `|`는 주로 특정 비트 값을 변경할 때 사용한다.  
비트AND연산자 `&`는 주로 특정 비트의 값을 뽑아낼 때 사용한다.  
비트XOR연산자 `^`는 두 피연산자의 비트가 다를 때만 1이 되고, 같은 값을 두고 XOR연산을 수행하면 원래의 값으로 돌아오는 특징이 있어서 간단한 암호화에 사용된다.  

비트 연산에도 피연산자의 타입을 일치시키는 산술 변환이 일어날 수 있다.  

- 예제 [[예제 3-28]](./OperatorEx28.java)  

### 1. 비트 전환 연산자 ~
이 연산자는 피연산자를 2진수로 표현했을 떄, 0은 1로, 1은 0으로 바꾼다. 논리부정 연산자 `!`와 유사하다.  
비트 전환 연산자에 의해 비트 전환되고 나면, 부호있는 타입의 피연산자는 부호가 반대로 변경된다. 즉, 피연산자의 1의 보수를 얻을 수 있는 것이다. 그래서 비트전환연산자를 1의 보수 연산자라고도 한다.  
예를 들어 10진수 10을 비트전환 연산한 결과는 -11이고, 이 갑은 10의 1의 보수이다.  
비트 전환 연산자는 피연산자의 타입이 int보다 작으면 int로 자동 형변환(산술 변환) 후에 연산하기 때문에 연산결과는 32자리의 2진수이다.  

- 예제 [[예제 3-29]](./OperatorEx29.java)  

### 2. 쉬프트 연산자 << >>
이 연산자는 피연산자의 각 자리(2진수로 표현했을 떄)를 '오른쪽(>>)' 또는 '왼쪽(<<)'으로 이동(shift)한다고 해서 쉬프트 연산자라고 이름이 붙여졌다.  
예를 들어 '8 << 2'는 왼쪽 피연산자인 10진수 8의 2진수를 왼쪽으로 2자리 이동하는데, 이 때 자리이동으로 저장범위를 벗어난 값들은 버려지고 빈 자리는 0으로 채워진다.  
반면 >> 연산자는 오른쪽으로 이동시키기 때문에 부호있는 정수는 부호를 유지하기 위해 왼쪽 피연산자가 음수인 경우 빈자리를 1로 채우고, 양수인 경우 0으로 채운다.  

> x << n 는 x * 2^n 의 결과와 같다.  
> x >> n 는 x / 2^n 의 결과와 같다.  

곱셈이나 나눗셈 연산자를 사용해도 같은 결과를 얻을 수 있는데, 굳이 쉬프트 연산자를 제공하는 이유는 속도 때문이다. 나눗셈 또는 곱셈 연산자를 사용하는 것보다 쉬프트 연산자를 사용하는 것이 더 빠르기 때문이다.  
그러나 프로그램의 실행속도도 중요하지만, 코드의 가독성도 중요하기 때문에 연산자 속도가 빠르더라도 가독성을 고려해봐야 한다.  

- 예제 [[예제 3-30]](./OperatorEx30.java)  
- 쉬프트 연산자와 비트AND연산자를 이용해서 16진수를 끝에서부터 한자리씩 뽑아낸다. [[예제 3-31]](./OperatorEx31.java)  

<br/><br/>

# 6. 그 외의 연산자

<br/>

## 조건 연산자 ? :

조건 연산자는 조건식, 식1, 식2 모두 세 개의 피연산자를 필요로 하는 삼항 연산자이며, 삼항 연산자는 조건 연산자 하나뿐이다.  
조건 연산자는 첫 번째 피연산자인 조건식의 평가결과에 따라 다른 결과를 반환한다. 조건식의 평과결과가 true이면 식1이, false이면 식2가 연산결과가 된다. 가독성을 위해 조건식을 괄호로 둘러싸는 경우가 많지만 필수는 아니다.  

```
result = (x > y) ? x : y;
```

- 예제 [[예제 3-32]](./OperatorEx32.java)  

<br/>

## 대입 연산자 = op=

대입 연산자는 변수와 같은 저장공간에 값 또는 수식의 연산결과를 저장하는데 사용된다. 이 연산자는 오른쪽 피연산자의 값을 왼쪽 피연산자에 저장하고, 저장된 값을 연산결과로 반환한다.  
대입연산자는 연산자들 중에서 가장 낮은 우선순위를 갖고 있기 때문에 식에서 제일 나중에 수행된다.  

### 1. lvalue과 rvalue
대입 연산자의 왼쪽 피연산자를 `lvalue(left value)`라고 하고, 오른쪽 피연산자를 `rvalue(right value)`라고 한다.  

### 2. 복합 대입 연산자
대입 연산자는 다른 연산자(op)와 결합하여 `op=`와 같은 방식으로 사용될 수 있다.  
예를 들어 i = i + 3은 i += 3과 같이 표현될 수 있다.
 



