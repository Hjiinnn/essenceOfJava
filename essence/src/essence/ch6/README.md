# Chapter06. 객체지향 프로그래밍

<br/>

# 1. 객체지향언어

## 객체지향이론

실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다.

<br/>

## 주요 특징

1. **코드의 재사용성이 높다.**

   새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.

2. **코드의 관리가 용이하다.**

   코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.

3. **신뢰성이 높은 프로그래밍을 가능하게 한다.**

   제어자의 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며,
   코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.

<br/>

# 2. 클래스와 객체

## 클래스와 객체의 정의와 용도

> **클래스의 정의** : 객체를 정의해 놓은 것  
> **클래스의 용도** : 객체를 생성하는데 사용됨

> **객체의 정의** : 실제로 존재하는 것. 사물 또는 개념  
> **객체의 용도** : 객체가 가지고 있는 기능과 속성에 따라 다름

객체는 클래스에 정의된 내용대로 **메모리에 생성된 것** 을 뜻한다.  
클래스는 단지 객체를 생성하는데 사용될 뿐, 객체 그 자체는 아니다.  

<br/>

## 객체와 인스턴스

클래스로부터 객체를 만드는 과정을 클래스의 **인스턴스화(instantiate)** 라고 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 **인스턴스(instace)** 라고 한다.

<br/>

## 객체의 구성요소 - 속성과 기능

객체는 속성과 기능, 두 종류의 구성요소로 이루어져 있다. 즉, 객체는 속성과 기능의 집합이라고 할 수 있다.  
객체가 가지고 있는 속성과 기능을 그 객체의 **멤버(구성원, member)** 라고 한다.

<br/>

## 인스턴스의 생성과 사용

클래스를 선언한 것은 설계도를 작성한 것에 불과하므로, 인스턴스를 생성해야 객체를 사용할 수 있다.

```
클래스명 변수명;            // 클래스의 객체를 참조하기 위한 참조변수를 선언
변수명 = new 클래스명();    // 클래스의 객채를 생성 후, 객체의 주소를 참조변수에 저장
```

- 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야 한다.&nbsp;&nbsp;[[예제 6-1](./TvTest.java)]
- 같은 클래스로부터 생성되었을지라도 각 인스턴스의 속성(메멉변수)은 서로 다른 값을 유지할 수 있으며, 메서드의 내용은 모든 인스턴스에 대해 동일하다.&nbsp;&nbsp;[[예제 6-2](./TvTest2.java)]
- 참조변수에는 하나의 값(주소)만이 저장될 수 있으므로 둘 이상의 참조변수가 하나의 인스턴스를 참조하는 것은 가능하지만, 하나의 참조변수로 여러 개의 인스턴스를 참조하는 것은 가능하지 않다.&nbsp;&nbsp;[[예제 6-3](./TvTest3.java)]

<br/>

## 객체 배열

많은 수의 객체를 다뤄야 할 때, 객체를 배열로 다루는 것이 가능하며, 이를 **객체 배열** 이라고 한다.  
객체 배열 안에는 객체가 저장되는 것이 아니라 객체의 주소가 저장된다. 따라서, 객체 배열은 참조변수들을 하나로 묶은 참조변수 배열인 것이라고 할 수 있다.

```
Tv tv1, tv2, tv3;  --->  Tv[] tvArr = new Tv[3]
```

길이가 3인 객체 배열 tvArr을 생성하면, 각 요소는 참조변수의 기본값인 null로 초기화 된다.  
객체 배열을 생성하는 것은, 그저 객체를 다루기 위한 참조 변수들이 만들어진 것일 뿐, 아직 객체가 저장되지 않은 것이다. 객체를 생성해서 객체 배열의 각 요소에 저장하는 것이 필요하다.

```
방법1. 참조변수 생성 후 객체 배열의 각 요소에 객체 저장
Tv[] tvArr = new Tv[3];

tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();
-------------------------------------------------
방법2. 배열 생성 동시에 초기화
Tv[] tvArr = { new Tv(), new Tv(), new Tv() };
-------------------------------------------------
방법3. for문을 이용한 객체 저장
Tv[] tvArr = new Tv[3];

for(int i=0; i<tvArr.length; i++){
    tvArr[i] = new Tv();
}
```

[[예제 6-4](./TvTest4.java)]

<br/>

## 클래스의 또 다른 정의

**데이터와 함수의 결합**  
하나의 데이터를 저장하기 위해 변수를, 그리고 같은 종류의 데이터를 보다 효율적으로 다루기 위해서 배열이라는 개념을 도입했으며, 후에는 구조체가 등장하여 자료형의 종류에 상관없이 서로 관게가 깊은 변수들을 하나로 묶어서 다룰 수 있도록 하였다.

1. 변수 : 하나의 데이터를 저장할 수 있는 공간
2. 배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
3. 구조체 : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
4. 클래스 : 데이터와 함수의 결합(구조체 + 함수)

함수는 데이터를 가지고 작업을 하기 때문에 데이터와 함수의 관계는 깊다.  
자바와 같은 객체지향언어에서는 변수와 함수를 하나의 클래스에서 정의하여 서로 관계가 깊은 변수와 함수들을 함께 다룰 수 있게 했다.
이렇게 서로 관련된 변수들을 정의하고 이들에 대한 작업을 수행하는 함수들을 함께 정의한 것이 바로 클래스이다.

**사용자지정의 타입 (user-defined type)**  
프로그래밍언어에서 제공하는 자료형(primitive type)외에 프로그래머가 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것을 사용자정의 타입이라고 한다. 자바와 같은 객체지향언어에서는 클래스가 곧 사용자 정의 타입이다.

시간을 표현하기 위해서 아래와 같이 3개의 변수를 선언했다.

```
int hour;
int minute;
float second
```

만일 3개의 시간을 다루어야 한다면 다음과 같이 해야 할 것이다.

```
int hour1, hour2, hour3
int minute1, minute2, minute3
float second1, second2, second3
```

이처럼 다뤄야 하는 시간의 개수가 늘어날 때마다 변수를 추가해줘야 한다. 아래와 같이 배열로 처리한다면 데이터의 개수가 늘어나더라도 배열의 크기만 변경해주면 되므로, 변수를 매번 새로 선언해줘야 하는 불편함과 복잡함을 해소할 수 있다.

```
int [] hour = new int[3];
int [] minute = new int[3];
float [] second = new float[3];
```

그러나, 하나의 시간을 구성하는 시, 분, 초가 서로 분리되어 있기 때문에 프로그램 수행과정에서 데이터들이 뒤섞여 올바르지 않은 데이터가 될 가능성이 있다. 이런 경우 관련된 변수들을 하나로 묶는 사용자정의 타입, 즉 클래스를 정의해서 사용해야 한다.

```
class Time {
    int hour;
    int minute;
    int second;
}
```

이제 변수들이 하나로 묶여서 데이터들이 뒤섞이는 일은 없겠지만, 추가적인 제약조건이 있을 수 있다.  
객체지향언어에서 제약조건과 같은 것들은 제어자와 메서드를 이용해서 적용할 수 있다.

<br/>

# 3. 변수와 메서드

## 선언위치에 따른 변수의 종류

변수는 변수의 선언 위치에 따라 클래스변수, 인스턴스변수, 지역변수 이렇게 세 종류로 구분되기 대문에 변수의 종류를 파악하기 위해서는 변수가 어느 영역에 선언되었는지를 확인하는 것이 중요하다.  
멤버변수를 제외한 나머지 변수들은 모두 지역변수이며, 멤버변수 중 static이 붙은 것은 클래스 변수, 붙지 않은 것은 인스턴스 변수이다.

```
class Variables {
    int iv;         // 인스턴스 변수
    static int cv;  // 클래스변수(static변수, 공유변수)

    void method() {
        int lv = 0; // 지역변수
    }
}
```

<table>
<thead>
  <tr>
    <th>변수의 종류</th>
    <th>선언 위치</th>
    <th>생성 시기</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>클래스변수<br/>(class variable)</td>
    <td rowspan="2">클래스 영역</td>
    <td>클래스가 메모리에 올라갈 때</td>
  </tr>
  <tr>
    <td>인스턴스변수<br/>(instance variable)</td>
    <td>인스턴스가 생성될 때</td>
  </tr>
  <tr>
    <td>지역변수<br/>(local variable)</td>
    <td>클래스 영역 이외의 영역 <br/> (메서드, 생성자, 초기화 블럭 내부)</td>
    <td>변수 선언문이 수행되었을 때</td>
  </tr>
</tbody>
</table>

<br/>

### 1. 인스턴스 변수 (instance variable)

클래스 영역에 선언되며, 인스턴스 변수의 값을 읽거나 저장하기 위해서는 먼저 인스턴스를 생성해야 한다.  
인스턴스는 독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 있다. 인스턴스마다 `고유한 상태`를 유지해야하는 속성의 경우 인스턴스변수로 선언한다.

### 2. 클래스 변수 (class variable)

클래스변수는 모든 인스턴스가 공통된 저장공간(변수)을 공유하게 된다. 한 클래스의 모든 인스턴스들이 `공통적`인 값을 유지해야하는 속성의 경우 클래스변수로 선언한다.  
클래스변수는 인스턴스를 생성하지 않고도 바로 사용할 수 있으며 `클래스이름.클래스변수`와 같은 형식으로 사용한다.  
클래스가 메모리에 로딩(loading)될때 생성되어 프로그램이 종료될 때 까지 유지되며, public을 붙이면 같은 프로그램 내에서 어디서나 접근할 수 있는 전역변수(global variable)의 성격을 갖는다.

### 3. 지역 변수 (local variable)

메서드 내에 선언되어 메서드 내에서만 사용 가능하며, 메서드가 종료되면 소멸되어 사용할 수 없게 된다.

<br/>

## 클래스변수와 인스턴스변수

인스턴스변수는 인스턴스가 생성될 때마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만, 클래스변수는 모든 인스턴스가 하나의 저장공간을 공유하므로, 항상 공통된 값을 갖는다.&nbsp;&nbsp;[[예제 6-5](./CardTest.java)]

<br/>

## 메서드

메서드(method)는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것이다.  
메서드가 작업을 수행하는데 필요한 값만 넣고 원하는 결과를 얻으면 될 뿐, 내부적으로 어떤 과정을 거치는지는 몰라도 된다. 즉, 메서드에 넣을 값(입력)과 결과(출력)만 알면 되는 것이다.

1.  **높은 재사용성**  
    만들어 놓은 메서드는 몇 번이고 호출할 수 있으며, 다른 프로그램에서도 사용이 가능하다.
2.  **중복된 코드의 제거**  
    반복되는 문장들을 묶어서 하나의 메서드로 작성해 놓으면, 중복되는 문장들 대신 메서드를 호출할 수 있으며, 변경사항이 발생했을 때 이 메서드만 수정하면 되므로 관리도 쉽고 오류의 발생 가능성도 낮아진다.
3.  **프로그램의 구조화**  
    큰 규모의 프로그램에서는 문장들을 작업단위로 나눠서 여러 개의 메서드에 담아 프로그램의 구조를 단순화시키는 것이 필수적이다.

        ```
        public static void main(String args[]) {
            int[] numArr = new int[10];

            initArr(numArr);    // 1. 배열을 초기화
            printArr(numArr);   // 2. 배열을 출력
            sortArr(numArr);    // 3. 배열을 정렬
            printArr(numArr);   // 4. 배열을 출력
        }
        ```

        이처럼 main메서드는 프로그램의 전체 흐름이 한눈에 들어올 정도로 단순하게 구조화하는 것이 좋다. 그래야 나중에 문제가 발생해도 해당 부분을 쉽게 찾아서 해결할 수 있다.

<br/>

## 메서드의 선언과 구현

메서드는 크게 `선언부(header)`와 `구현부(body)`로 이루어져 있다.

```
반환타입 메서드이름 (타입 변수명, 타입 변수명, ... ) {         --> 선언부
    // 메서드 호출시 수행될 코드                              --> 구현부
}
```

### 메서드 선언부 (method declaration, method header)

메서드 선언부는 '메서드의 이름'과 '매개변수 선언', 그리고 '반환타입'으로 구성되어 있으며, 메서드가 작업을 수행하기 위해 어떤 값들을 필요로 하고 작업의 결과로 어떤 타입의 값을 반환하는 지에 대한 정보를 제공한다.  
메서드의 선언부는 후에 변경사항이 발생하지 않도록 신중히 작성해야 한다. 메서드의 선언부를 변경하게 되면, 그 메서드가 호출되는 모든 곳도 같이 변경해야하기 때문이다.

- ### 매개변수 선언 (parameter declaration)

  매개변수는 메서드가 작업을 수행하는데 필요한 값들(입력)을 제공받기 위한 것이며, 필요한 값의 개수만큼 변수를 선한다.

- ### 메서드의 이름 (method name)

  메서드는 특정 작업을 수행하므로 메서드의 이름은 동사인 경우가 많으며, 이름만으로도 메서드의 기능을 쉽게 알 수 있도록 함축적이면서도 의미있는 이름을 짓도록 노력해야 한다.

- ### 반환타입 (return type)

  메서드의 작업수행 결과(출력)인 반환값의 타입을 적는다. 반환값이 없는 경우에는 반환타입으로 `void`를 적는다.

### 메서드의 구현부 (method body)

메서드를 호출했을 때 수행될 문장들이다.

- ### return문
  메서드의 반환타입이 `void`가 아닌 경우 구현부 안에 `return 반환값;`이 반드시 포함되어 있어야 한다. 이 문장은 작업을 수행한 결과인 반환값을 호출한 메서드로 전달하는데, 이 값의 타입은 반환타입과 일치하거나 적어도 자동 형변환이 가능한 것이어야 한다.

<br/>

## 메서드의 호출

메서드를 정의했어도 호출되지 않으면 아무 일도 일어나지 않는다.

```
메서드이름(값1, 값2, ...);
```

### 인자(argument)와 매개변수(parameter)

메서드를 호출할 때 괄호 안에 지정해준 값들을 `인자(argument)` 또는 `인수`라고 한다.

### 메서드의 실행흐름

같은 클래스 내의 메서드끼리는 참조변수를 사용하지 않고도 서로 호출이 가능하지만 _static메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수 없다._

[[예제 6-6](./MyMathTest.java)]

<br/>

## return문

return문은 현재 실행중인 메서드를 종료하고 호출한 메서드로 되돌아간다. 반환값의 유무에 관계없이 모든 메서드에는 적어도 하나의 return문이 있어야 한다. 반환타입이 void의 경우 컴파일러가 메서드의 마지막에 `return;`을 자동적으로 추가해준다.  
그러나 반환타입이 void가 아닌 경우 반드시 return문이 있어야 한다.

### 매개변수의 유효성 검사

메서드의 구현부를 작성할 때, 제일 먼저 해야 하는 일이 매개변수의 값이 적절한 것인지 확인하는 것이다. 적절하지 않은 값이 매개변수를 통해 넘어온다면 매개변수의 값을 보정하든가, 보정하는 것이 불가능하다면 return문을 사용해서 작업을 중단하고 호출한 메서드로 되돌아가야 한다.

<br/>

## JVM의 메모리 구조

응용프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.

1. **메서드 영역 (method area)**  
   프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(\*.class)을 읽어서 분석하여 클래스에 대한 정보를 이 곳에 저장한다. 이 때, 클래스의 변수 (class variable)도 이 영역에 함께 생성된다
2. **힙 (heap)**  
   인스턴스가 생성되는 공간. 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다. 즉, 인스턴스변수(instance variable)들이 생성되는 공간이다.
3. **호출스택 (call stack 또는 execution stack)**  
   호출스택은 메서드의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스택에 호출된 메서드이 때를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다. 그리고 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워진다.  
   [[예제 6-7](./CallStackTest.java)] [[예제 6-8](./CallStackTest2.java)]

<br/>

## 기본형 매개변수와 참조형 매개변수

자바에서는 메서드를 호출할 때 매개변수로 지정한 값을 메서드의 매개변수에 복사해서 넘겨준다. 매개변수 타입이 기본형(primitive type)일 때는 기본형 값이 복사되겠지만, 참조형(reference type)이면 인스턴스의 주소가 복사된다.  
메서드의 매개변수를 기본형으로 선언하면 단순히 저장된 값만 얻지만, 참조형으로 선언하면 저장된 곳의 주소를 알 수 있기 때문에 값을 읽어 오는 것은 물론 값을 변경하는 것도 가능하다.

- 기본형 매개변수(primitive Param)는 값을 읽기만 할 수 있다. (Read Only) &nbsp;&nbsp;[[예제 6-9](./PrimitiveParamEx.java)]
- 참조형 매개변수(Reference Param)는 값을 읽고 변경할 수 있다. (Read and Write) &nbsp;&nbsp;[[예제 6-10](./ReferenceParamEx.java)]&nbsp;&nbsp;[[예제 6-11](./ReferenceParamEx2.java)]&nbsp;&nbsp;[[예제 6-12](./ReferenceParamEx3.java)]
- 참조형 매개변수를 활용하면 반환값이 없어도 메서드의 실행결과를 얻어올 수 있다. &nbsp;&nbsp;[[예제 6-13](./ReturnTest.java)]

<br/>

## 참조형 반환타입

매개변수뿐만 아니라 반환타입도 참조형이 될 수 있다. 모든 참조형 타입의 값은 `객체의 주소`이다.  
반환타입이 참조형이라는 것은 메서드가 객체의 주소를 반환한다는 것을 의미한다. &nbsp;&nbsp;[[예제 6-14](./ReferenceRetrunEx.java)]

<br/>

## 재귀호출 (recursive call)

메서드의 내부에서 메서드 자신을 다시 호출하는 것을 **재귀호출(recursive call)** 이라 하고, 재귀호출을 하는 메서드를 **재귀 메서드** 라고 한다.

```
void method() {
    method();       // 재귀호출. 메서드 자신을 호출한다.
}
```

호출된 메서드는 '값에 의한 호출(call by value)'을 통해, 원래의 값이 아닌 복사된 값으로 작업하기 때문에 호출한 메서드와 관계없이 독립적인 작업수행이 가능하다.  
그런데 위의 코드처럼 오로지 재귀호출뿐이면, 무한반복에 빠지기 때문에 재귀호출도 `조건문`이 필수적으로 따라다닌다.

```
void method(int n) {
    if(n == 0) {
        return;      // n이 0일 때, 메서드 종료
    }
    System.out.println(n);

    method(--n);    // 재귀호출
}
```

재귀호출은 반복문과 유사한 점이 많으며, 대부분의 재귀호출은 반복문으로 작성하는 것이 가능하다.  
반복문은 그저 같은 문장을 반복해서 수행하는 것이지만, 메서드를 호출하는 것은 반복문보다 몇 가지 과정 (매개변수 복사와 종료 후 복귀할 주소 저장 등)이 추가적으로 필요하기 때문에 **재귀호출의 수행시간이 더 오래걸린다**.  
재귀호출은 비효율적이더라도 알아보기 쉽게 작성할 수 있기 때문에 논리적 오류가 발생할 확률도 줄어들고 수정하기도 좋다. 반복문을 작성했는데 너무 복잡하다면 재귀호출로 간단히 할 수 없는지 고민해볼 필요가 있다.  
[[예제 6-15](./FactorialTest.java)] &nbsp;[[예제 6-16](./FactorialTest2.java)]  
무한호출에 빠지게 되면 메서드가 종료되지 않고 호출스택에 계속해서 쌓이게 되므로 결국 호출스택의 메모리 한계를 넘게 되고 `StatckOverflowError`가 발생하여 프로그램은 비정상적으로 종료된다.&nbsp;&nbsp;[[예제 6-17](./MainTest.java)]   
- x^1 부터 x^n까지의 합 구하기 &nbsp;&nbsp;[[예제 6-18](./PowerTest.java)]

<br/>

## 클래스 메서드와 인스턴스 메서드

크래스 메서드도 클래스변수처럼 객체를 생성하지 않고도 `클래스이름.메서드이름`와 같은 식으로 호출이 가능한 반면, 인스턴스 메서드는 반드시 객체를 생성해야만 호출할 수 있다.  
클래스는 데이터와 데이터에 관련된 메서드의 집합이므로, 같은 클래스 내에 있는 메서드와 멤버변수는 아주 밀접한 관계가 있다.  
**인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는, 즉 메서드의 작업을 수행하는 데 인스턴스 변수를 필요로하는 메서드이다.**
그런데 인스턴스 변수는 인스턴스(객체)를 생성해야만 만들어지므로 인스턴스 메서드 역시 인스턴스를 생성해야만 호출할 수 있는 것이다.  
**반면에인스턴스와 관계없는 (인스턴스 변수나 메서드를 사용하지 않는) 메서드를 클래스 메서드로 정의한다.**

1. **클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.**  
   생성된 각 인스턴스는 서로 독립적이기 때문에 각 인스턴스의 변수(iv)는 서로 다른 값을 유지한다. 그러나 모든 인스턴스에서 같은 값이 유지되어야 하는 변수는 static을 붙여서 클래스변수로 정의해야 한다.

2. **클래스변수는 인스턴스를 생성하지 않아도 사용할 수 있다.**  
   static이 붙은 클래스가 메모리에 올라갈 때 이미 자동적으로 생성되기 때문이다.

3. **클래스메서드는 인스턴스변수를 사용할 수 없다.**  
   클래스메서드는 인스턴스 생성 없이 호출이 가능하므로 클래스 메서드가 호출되었을 때 인스턴스가 존재하지 않을 수도 있다. 그래서 클래스 메서드에서 인스턴스변수의 사용을 금지한다. 반면에 인스턴스변수나 메서드에서는 static이 붙은 멤버들을 사용하는 것이 언제나 가능하다. 인스턴스 변수가 존재한다는 것은 static변수가 이미 메모리에 존재한다느 것을 의미하기 때문이다.

4. **메서드 내에서 인스턴스변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.**  
   인스턴스 변수를 필요로 하지 않는다면 static을 붙이는 것이 좋다. 메서드 호출시간이 짧아지므로 성능이 향상되기 때문이다. static을 붙이지 않은 인스턴스메서드는 실행 시 호출되어야 할 메서드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더 걸린다.

[[예제 6-19](./MyMathTest2.java)]

<br/>

## 클래스 멤버와 인스턴스 멤버간의 참조와 호출

같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하지만, 클래스멤버가 인스턴스멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 한다. **인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문이다.** &nbsp;&nbsp;[[예제 6-20](./MemberCall.java)]

```
class TestClass {
    void instanceMethod() {}        // 인스턴스 메서드
    static void staticMethod() {}   // static 메서드

    void instatnceMethod2() {
        instanceMethod();
        staticMethod();
    }

    static void staticMethod2() {
        instatanceMethod();         // ERROR!!! 인스턴스메서드를 호출할 수 없다.
        staticMethod();
    }
}

--------------------------------------------------------------------------------------

class TestClass2 {
   int Tv;              // 인스턴스 변수
   static int cv;       // 클래스 변수

   void instanceMethod() {
        System.out.println(iv);
        System.out.println(cv);
   }

   static void staticMethod() {
        System.out.println(iv);     // ERROR!!! 인스턴스 변수를 사용할 수 없다.
        System.out.println(cv);
   }
}
```

하지만, **인스턴스멤버간의 호출에는 아무런 문제가 없다. 하나의 인스턴스멤버가 존재한다는 것은 이미 인스턴스가 생성되어있다는 것을 의미한다. 즉, 다른 인스턴스멤버들도 모두 존재하기 때문이다.**

<br/><br/>

# 4. 오버로딩(overloading)

## 오버로딩이란?

자바에서는 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메서드가 있더라도 매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메서드를 정의할 수 있다.  
이처럼 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 `메서드 오버로딩(method overloading)`이라고 한다.

<br/>

## 오버로딩의 조건

1. 메서드 이름이 같아야 한다.
2. 매개변수의 개수 또는 타입이 달라야 한다.

비록 메서드의 이름이 같다 하더라도 매개변수가 다르면 서로 구별될 수 있기 때문에 오버로딩이 가능하다. 그리고 오버로딩된 메서드들은 매개변수에 의해서만 구별될 수 있으므로 **반환타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다**는 것에 주의해야 한다.

<br/>

## 오버로딩 예

```
int add(int a, int b) { return a + b; }
int add(int x, int y) { return x + y; }
```

위의 두 메서드는 매개변수의 이름만 다를 뿐 매개변수의 타입이 같기 때문에 오버로딩이 성립하지 않는다.

```
int add(int a, int b) { return a + b; }
long add(int a, int b) { return (long) a + b; }
```

이 경우에는 리턴타입만 다른 경우이다. 매개변수의 타입과 개수가 일치하기 대문에 어떤 메서드가 호출된 것인지 결정할 수 없으므로 오버로딩으로 간주하지 않는다.

```
long add(int a, long b) { return a + b; }
long add(long a, int b) { return a + b; }
```

두 메서드 모두 int형과 long형 매개변수가 하나씩 선언되어 있지만, 서로 순서가 다르므로 메서드 호출 시 매개변수 값에 의해 구분될 수 있기 때문에 오버로딩으로 간주한다.

<br/>

## 오버로딩의 장점

모두 근본적으로 같은 기능을 하는 메서드들이지만, 서로 다른 이름을 가져야 한다면 이름을 짓기도 어렵고, 사용하는 쪽에서도 불편할 것이다.  
하지만 오버로딩을 통해 여러 메서드들이 하나의 이름으로 정의될 수 있다면 기억하기도 쉽고 이름을 짓기도 쉬우며, 어떤 기능인지 예측할 수 있다.  
[[예제 6-21](./OverloadingTest.java)]

<br/>

## 가변인자(varargs)와 오버로딩

기존에는 메서드의 매개변수 개수가 고정적이었으나 JDK1.5부터는 동적으로 지정해 줄 수 있게 되었으며, 이 기능을 `가면인자(variable arguments)`라고 한다.  
가변인자는 `타입... 변수명`과 같은 형식으로 선언하며, Printstream클래스의 printf()가 대표적인 예이다.

```
public PrintStream printf(String format, Object... args) { ... }
```

위와 같이 가변인자 외에도 매개변수가 더 있다면, 가변인자ㅡㄹㄹ 매개변수 중에서 제일 마지막에 선언해야 한다. 그렇지 않으면, 컴파일 에러가 발생한다. 가변인자인지 아닌지를 구별할 방법이 없기 때문이다.

```
// ERROR!!! - 가변인자는 항상 마지막 매개변수이어야 한다.
public PrintStream printf(Object... args, String format) {

}
```

만일 여러 문자열을 하나로 결합하여 반환하는 concatenate메서드를 작성한다면 아래와 같이 매개변수의 개수를 다르게 해서 여러 개의 메서드를 작성해야할 것이다.

```
String concatenate(String s1, String s2) { ... }
String concatenate(String s1, String s2, String s3) { ... }
String concatenate(String s1, String s2, String s3, String s4) { ... }
```

이럴 때 가변인자를 사용하면 메서드 하나로 간단히 대체할 수 있다.

```
String concatenate(String... str) { ... }
```

가변인자는 내부적으로 배열을 이용한다. 그래서 가변인자가 선언된 메서들르 호출할 때마다 배열이 새로 생성되는데, 이는 비효율적이므로 꼭 필요한 경우에만 가변인자를 사용하도록 해야한다.  
가변인자를 선언한 메서드를 오버로딩하면, 메서드를 호출했을 때 구별되지 못하는 경우가 발생할 수 있기 때문에 가변인자를 사용한 메서드는 오버로딩 하지 않는 것이 좋다. &nbsp;&nbsp;[[예제 6-22](./VarArgsEx.java)]

<br/>

# 5. 생성자(Constructor)

## 생성자란?

생성자는 인스턴스가 생성될 때 호출되는 **인스턴스 초기화 메서드**이다. 따라서 인스턴스 변수의 초기화 작업에 주로 사용되며, **인스턴스 생성 시에 실행되어야 할 작업**을 위해서도 사용된다.  
생성자는 메서드와 유사하지만 **리턴값이 없다**는 점이 다르다.

1. 생성자의 이름은 클래스의 이름과 같아야 한다.
2. 생성자는 리턴값이 없다.

```
클래스이름(타입 변수명, 타입 변수명, ...) {
    // 인스턴스 생성 시 실행될 코드,
    // 주로 인스턴스 변수의 초기화 코드를 적는다.
}
```

**연산자 new가 인스턴스를 생성하는 것이지, 생성자가 인스턴스를 생성하는 것이 아니다.** 생성자는 단순히 인스턴스변수들의 초기화에 사용되는 특별한 메서드일 뿐이다.

```
Card c = new Card();

1. 연산자 new에 의해 메모리(heap)에 Card클래스의 인스턴스가 생성된다.
2. 생성자 Card()가 호출되어 수행된다.
3. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다.
```

인스턴스를 생성하기 위해 사용해왔던 `클래스이름()`이 바로 생성자였던 것이다. 인스턴스를 생성할 때는 반드시 클래스 내에 정의된 생성자 중의 하나를 선ㅌ낵하여 지정해주어야 한다.

<br/>

## 기본 생성자(default constructor)

클래스에 생성자를 정의하지 않고도 인스턴스를 생성할 수 있었던 이유는 컴파일러가 제공하는 **기본 생성자(default constructor)** 덕분이다.  
컴파일 할 때, 소스파일(\*.java)의 클래스에 생성자가 하나라도 정의되지 않은 경우 컴파일러는 자동적으로 기본 생성자를 추가하여 컴파일한다.

```
클래스이름() {}
```

기본 생성자가 컴파일러에 의해 추가되는 경우는 클래스에 정의된 생성자가 하나도 없을 때 뿐이다. &nbsp;&nbsp;[[예제 6-23](./ConstructorTest.java)]

<br/>

## 매개변수가 있는 생성자

생성자도 메서드처럼 매개변수를 선언하여 호출 시 값을 넘겨받아서 인스턴스의 초기화 작업에 사용할 수 있다.  
**인스턴스마다 각기 다른 값으로 초기화되어야 하는 경우**에 유용하다.

```
class Car {
    String color;
    String gearType;
    int door;

    // 생성자
    Car() {}
    Car(String c, String g, int d) {
        color = c;
        gearType = g;
        door = d;
    }
}
```

여기서 Car 인스턴스를 생성할 때, 생성자 Car()을 사용한다면, 인스턴스를 생성한 다음에 인스턴스변수들을 따로 초기화 해주어야 하지만, 매개변수가 있는 생성자를 사용한다면 인스턴스를 생성하는 동시에 초기화를 할 수 있게 된다. &nbsp;&nbsp;[[예제 6-24](./CarTest.java)]

<br/>

## 생성자에서 다른 생성자 호출하기 - this(), this

같은 클래스 멤버들 간에 서로 호출할 수 있는 것처럼 생성자 간에도 서로 호출이 가능하다.

- 생성자 이름으로 클래스이름 대신 this를 사용한다.
- 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.

```
Car(String color) {
    door = 5;
    Car(color, "auto", 4);  // ERROR!!! 생성자의 두번째 줄에서 다른 생성자 호출, this로 해야 함.
}
```

생성자에서 다른 생성자를 첫 줄에서만 호출이 가능하도록 한 이유는 생성자 내에서 초기화 작업도중에 다른 생성자를 호출하게 되면, 호출된 다른 생성자 내에서도 멤버변수들의 값을 초기ㅗ하를 할 것이므로 다른 생성자를 호출하기 이전의 초기화 작업이 무의미해질 수 있기 때문이다.

생성자의 매개변수로 인스턴스변수들의 초기값을 제공받는 경우 매개변수와 인스턴스변수의 이름이 일치하는 경우가 자주 있다. 이때는 매개변수의 이름을 다르게 하기 보다 `this`를 사용해서 구별되도록 하는 것이 더 의미가 있다.  
**`this`는 참조변수로 인스턴스 자신을 가리킨다.** 참조변수를 통해 인스턴스의 멤버에 접근할 수 있는 것처럼, `this`로 인스턴스변수에 접근할 수 있는 것이다.  

```
this: 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다. 모든 인스턴스메서드에 지역변수로 숨겨진 채로 존재한다.
this(), this(매개변수) 생성자: 같은 클래스의 다른 생성자를 호출할 때 사용한다.
```

this와 this()는 비슷하게 생겼을 뿐 완전히 다른 것이다. `this`는 **참조변수**이고, `this()`는 **생성자**이다. &nbsp;&nbsp;[[예제 6-25](./CarTest2.java)]

<bn/>

## 생성자를 이용한 인스턴스의 복사

현재 사용하고 있는 인스턴스와 같은 상태를 갖는 인스턴스를 하나 더 만들고자 할 때 생성자를 이용할 수 있다. 하나의 클래스로부터 생성된 모든 인스턴스의 메서드와 클래스변수는 서로 동일하기 때문에 인스턴스간의 차이는 인스턴스마다 각기 다른 값을 가질 수 있는 인스턴스 변수 뿐이다. &nbsp;&nbsp;[[예제 6-26](./CarTest3.java)]

<br/>

# 6. 변수의 초기화

## 변수의 초기화

변수의 초기화는 가능하다면 선언과 동시에 적절한 값으로 초기화하는 것이 바람직하다.  
멤버변수는 초기화를 하지 않아도 자동적으로 변수의 자료형에 맞는 기본값으로 초기화가 이루어지므로 초기화를 하지 않고 사용해도 되지만, 지역변수는 사용하기 전에 반드시 초기화를 해야 한다.

```
class InitTest {
    int x;
    int y = x;

    void method1() {
        int i;
        int j = i;  // ERROR!!! 지역변수를 초기화하지 않고 사용함
    }
}
```

**멤버변수와 배열의 초기화는 선택적이지만, 지역변수의 초기화는 필수적이다.**

<br/>

## 명시적 초기화 (explicit initalization)

변수를 선언과 동시에 초기화하는 것을 명시적 초기화라고 한다.

```
class Car {
    int door = 4;               // 기본형(primitive type) 변수의 초기화
    Engine e = new Engine();    // 참조형(reference type) 변수의 초기화
}
```

명시적 초기화가 간단하고 명료하지만, 복잡한 초기화 과정이 필요할 때는 `초기화 블럭(initialization block)` 또는 생성자를 사용해야 한다.

<br/>

## 초기화 블럭 (initialization block)

**클래스 초기화 블럭** : 클래스변수의 복잡한 초기화 과정에 사용된다.  
**인스턴스 초기화 블럭** : 인스턴스변수의 복잡한 초기화에 사용된다.

초기화 블럭 내에서는 메서드 내에서와 같이 조건문, 반복문, 에외처리구문 등을 자유롭게 사용할 수 있으므로, 초기화 작업이 복잡하여 명시적 초기화만으로는 부족한 경우 초기화 블럭을 사용한다.

```
class InitBlock {
    static { /* 클래스 초기화 블럭 */}

    {/* dlstmxjstm chrlghk qmffjr */}
}
```

클래스 초기화블럭은 클래스가 메모리에 처음 로딩될 때 한번만 수행되며, 인스턴스 초기화 블럭은 생성자와 같이 인스턴스를 생성할 때마다 수행된다. 그리고 **생성자보다 인스턴스 초기화 블럭이 먼저 수행된다.**  
클래스가 처음 로딩될 때 클래스변수들이 자동적으로 메모리에 만들어지고, 곧바로 클래스 초기화블럭이 클래스변수들을 초기화하게 된다.

인스턴스 변수의 초기화는 주로 생성자를 사용하고, 인스턴스 초기화 블럭은 모든 생성자에서 공통으로 수행되어야 하는 코드를 넣는데 사용한다.

```
Car() {
    count++;
    serialNo = count;
    color = "white";
    gearType = "Auto";
}

Car(String color, String gearType) {
    count++;
    serialNo = count;
    this.color = color;
    this.gearType = gearType;
}

--------------------------------------------

// 인스턴스 초기화 블럭
{
    count++;
    serialNo = count;
}

car () {
    color = "white";
    gearType = "Auto";
}

Car(String color, String gearType) {
    this.color = color;
    this.gearType = gearType;
}
```

이처럼 코드의 중복을 제거하는 것은 코드의 신뢰성을 높여 주고, 오류의 발생가능성을 줄여준다는 장점이 있다. 즉, **재사용성을 높이고 중복을 제거하는 것** 이것이 바로 객체지향프로그래밍이 추구하는 궁극적인 목표이다. &nbsp;&nbsp;[[예제 6-27](./BlockTest.java)]  
배열이나 예외처리가 필요한 초기화에서는 명시적 초기화만으로는 복잡한 초기화 작업을 할 수 없으므로 클래스 초기화 블럭을 사용하는 것이 좋다. &nbsp;&nbsp;[[예제 6-28](./StaticBlockTest.javaBlockTest.java)]

<br/>

## 멤버변수의 초기화 시기와 순서

**클래스변수의 초기화 시점**  
클래스가 처음 로딩될 때 단 한번 초기화 된다.

**인스턴스변수의 초기화 시점**  
인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다.

**클래스변수의 초기화 순서**  
기본값 -> 명시적초기화 -> 클래스 초기화 블럭

**인스턴스변수의 초기화 순서**  
기본값 -> 명시적초기화 -> 인스턴스 초기화 블럭 -> 생성자

프로그램 실행 도중 클래스에 대한 정보가 요구될 때, 클래스는 메모리에 로딩된다. 하지만, 해당 클래스가 이미 메모리에 로딩되어있다면, 또다시 로딩하지 않으므로 초기화도 수행되지 않는다.  
클래스변수는 항상 인스턴스변수보다 먼저 생성되고 초기화된다.

[[예제 6-28](./PowerTest.java)]
[[예제 6-29](./DocumentTest.java)]
